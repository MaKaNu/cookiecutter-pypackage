{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cookiecutter PyPackage","text":"<p>Cookiecutter template for a Python package. Powered by Poetry, GitHub actions, and MkDocs-Material.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to cookiecutter-pypackage! The creation of this project was inspired by the want for an easy-to-configure repository setup where everything could be done within GitHub. In the current state, the repositories created from the cookiecutter uses only GitHub for continuous integration and continuous deployment (CI/CD) via GitHub Actions. This allows for developers to create, test, and deploy their package(s) in an easy-to-use and easy-to-maintain way. </p>"},{"location":"#file-structure","title":"File structure","text":"<p>All code developed should go within the directory with your project-name given. The packaging works with a single file of code or multiple modules nested within sub-directories. For an example of structuring that allows for easy imports, check out my bowline package.</p>"},{"location":"#features","title":"Features","text":"<p>This template has the following features:  </p> <ul> <li><code>pytest</code>: Unit and coverage testing  </li> <li><code>flake8</code> and <code>pylint</code>: Python style checks  </li> <li><code>black</code>: Auto-formatted code  </li> <li><code>mypy</code>: Type checking  </li> <li><code>Poetry</code>: Depedency management and packaging  </li> <li><code>GitHub Actions</code>: Automated CI checks, auto-release to PyPi, and automated version bumping (no more Travis needed)  </li> <li><code>MkDocs-Material</code>: Auto-publish documentation to it's own webpage  </li> </ul> <p>This is a simple list, for a deep-dive into why and how each feature is used visit feature explanation. If already familiar or just not interested, continue to Getting started.</p>"},{"location":"advanced/feature_explanation/","title":"Feature Explanation","text":""},{"location":"advanced/feature_explanation/#pytest","title":"Pytest","text":"<p>Pytest is the package used for unit and coverage testing within the cookiecutter. I've chosen it over <code>unittest</code> as I find it easier to use and understand the results of. In addition, I like the native fixture functionality of pytest and the <code>pytest-cov</code> extension (used for coverage testing).</p>"},{"location":"advanced/feature_explanation/#flake8-and-pylint","title":"Flake8 and Pylint","text":"<p>Flake8 and Pylint are both linters developed by the Python Code Quality Authority (PyCQA). As pylint is typically more exhaustive I select it for the default. If you want to be excessive (as I am with my repos), add flake8 to be sure the proper style guides are followed. </p>"},{"location":"advanced/feature_explanation/#black","title":"Black","text":"<p>Black is my go-to code formatter. Although annoying in the beginning, I've grown to love black as it makes git diffs 100x easier. With strict and opionated formatting, it does all the tedious formatting you're too lazy to do and leaves your pull requests with only the important changes being highlighted.</p>"},{"location":"advanced/feature_explanation/#mypy","title":"Mypy","text":"<p>Mypy is the official checker for type-hinting which was added in Python 3.6. I think type-hinting allows for way better readability of Python code. Additionally, it makes sure that variables being passed throughout your program are being correctly accounted for in terms of their type (passing a string of \"1\" when it should be 1 can cause issues down the line).</p>"},{"location":"advanced/feature_explanation/#poetry","title":"Poetry","text":"<p>Poetry is the dependency manager and packager for the cookiecutter. As I've grown frusturated with older tools for Python packaging (setuptools, tox, etc.) I decided to give Poetry a try and it was 100% worth it. It comprises all the necessary settings into a single <code>pyproject.toml</code> file (instead of <code>setup.py/cfg</code>, <code>requirements.txt</code>, <code>MANIFEST.in</code>, etc.) which has growing use by the above packages (with pylint, pytest, and black already supporting). Poetry is one of the main reasons the CI files are short and sweet and the repository is not overrun with packaging files.</p>"},{"location":"advanced/feature_explanation/#github-actions","title":"Github Actions","text":"<p>GitHub Actions is still pretty new to the CI space and is probably the biggest split (with Poetry) I use from most Python repositories. The main reason for using GitHub Actions is it's free (up to 2,000/minutes a month) and it's where my code exists. A lot of open-source projects use TravisCI or other services which I think adds complexity to developing and maintaining a project.</p>"},{"location":"advanced/feature_explanation/#mkdocs-material","title":"MkDocs-Material","text":"<p>MkDocs-Material is the theme, builder, and publisher (extending MkDocs) for the documentation. The ease-of-use (I think you're seeing a pattern) of developing and deploying the documentation is a big win. Being able to edit the .md files and see the changes in real-time is a huge win. Furthermore, I think the resulting pages are the most visually appealing of any documentation framework I've worked with.</p> <p>Note an ideal state would be to have versioning for the documentation but you have to be an MkDocs-Material insider for that at the moment so it isn't supported by default.</p>"},{"location":"advanced/feature_explanation/#development-process","title":"Development process","text":"<p>Although this isn't a feature per-se, I think it's important to address as it's how I built the cookiecutter structure. The main drive behind having the CI checks on the <code>main</code> and <code>development</code> branches is so these are typically \"protected\" from having bad code. In addition, having the test pypi before pypi allows for user-testing of a new release without pushing out code that isn't ready for production. Lastly, I have the documentation auto-publish when <code>main</code> is updated as I only put code to main when it's ready to be released.</p>"},{"location":"getting-started/configure_github_repo/","title":"Configure GitHub repository","text":""},{"location":"getting-started/configure_github_repo/#setup-branches","title":"Setup branches","text":"<p>Now that we've pushed our repository to GitHub we'll see a <code>main</code> branch with all the code but you rarely want to push code directly to main. To mitigate this, lets create a <code>development</code> branch for which to actively develop code and then move it to main once we think it's safe for production. To do so, simply: </p> <ol> <li>Click on the \"main\" dropdown button your repo's homepage</li> <li>Type in \"development\" in the search bar</li> <li>Select \"Create branch: development from main\".</li> </ol> <p>Note if 'development' is not used. You must change the branch reference in certain files within the '.github/workflows' directory for CI checks to work.</p> <p>As seen with main, you'll see Actions being run for development. Additionally, whenever you open a pull request (PR) from development to main, the checks will automatically run to make sure the code is safe for merging.</p> <p>That is the base needed for the CI system to work. If you wish to add further protection to your repository visit the <code>Settings -&gt; Branches</code> section of your repo. This will allow you to add things like not allow code into a certain branch until it passes all CI checks and/or has been approved by at least 1 admin/contributer.</p>"},{"location":"getting-started/configure_github_repo/#setup-documentation-page","title":"Setup documentation page","text":"<p>As mentioned in the previous section, your repo magically (done by Github Actions) created a <code>gh-pages</code> branch. All the files in that branch are automatically generated from the files in the repository's <code>docs</code> folder. For more information on how to add pages to this documentation visit MkDocs-Material docs.</p> <p>To publish the docs to your own github site do the following:</p> <ol> <li>Go to \"Settings\" section.</li> <li>Scroll down to \"GitHub Pages\" section.</li> <li>Within the \"Source\" section select <code>gh-pages</code> branch and <code>/(root)</code>.</li> <li>Click \"Save\" button.</li> </ol> <p>Scroll back down to \"GitHub Pages\" and a link should be given for where your docs will be published (wait a few minutes for publication). In addition, this link can be added in the <code>About</code> section of your repository under \"website\" to display the link in a nice area.</p> <p>Now your repository has been properly configured! With proper code quality checks and automatically publishing documentation, you're just one more step away to having the infrastructure to develop an open-source Python package.</p>"},{"location":"getting-started/configure_github_repo/#setting-up-the-navigation-system","title":"Setting up the Navigation system","text":"<p>Because the docs only start with an <code>index.md</code> file, there's no need / way to setup a more complete navigation system (otherwise known as the page tree). To set this up, reference the nav section of this cookiecutter's <code>mkdocs.yml</code> file. Note that each highest level list item becomes part of the top nav and then all nested items are shown within each section.</p>"},{"location":"getting-started/connect_to_remote_repo/","title":"Connect to remote repository on GitHub","text":""},{"location":"getting-started/connect_to_remote_repo/#initialize-local-repository","title":"Initialize local repository","text":"<p>Now lets initialize a git repository within the created project for version control. First, move into the directory of the project.  </p> <p><code>$ cd project-name/</code></p> <p>Then, setup poetry dependency manager,  </p> <p><code>$ pip install poetry &amp;&amp; poetry install</code></p> <p>For more info on poetry, check out their docs. </p> <p>Lastly, initialize the repo.  </p> <p><code>$ git init</code> </p> <p>This will create a git repository within the project. Don't do anything just yet with it.</p>"},{"location":"getting-started/connect_to_remote_repo/#create-remote-repository-on-github","title":"Create remote repository on GitHub","text":"<p>If it hasn't already been created, we'll have to create a remote repository on GitHub. To do so, follow the steps:  </p> <ol> <li>Go to GitHub's create new repository page.</li> <li>Fill in the name and description with the values given at project creation.</li> <li>Make your choice of Public or Private.</li> <li>Leave all other boxes unchecked.</li> </ol>"},{"location":"getting-started/connect_to_remote_repo/#activate-write-access-for-github-action-runner","title":"Activate write access for github action runner","text":"<p>The default access rule of a fresh repository is set to \"Read repository contents and package permissions\". This will prevent the creation of github-pages. To allow the runner to create pages, the \"Workflow permissions\" need to be set to \"Read and write permissions\". Additionally, the checkbox \"Allow GitHub Actions to create and approve pull requests\" might be activated.</p>"},{"location":"getting-started/connect_to_remote_repo/#sync-local-repository-with-github","title":"Sync local repository with GitHub","text":""},{"location":"getting-started/connect_to_remote_repo/#add-remote-link","title":"Add remote link","text":"<p>Let's start with adding the newly created remote repository to the local repostiory so it knows where to push changes to. To do so run:  </p> <p><code>$ git remote add origin link_to_repo</code></p> <p>Make sure to replace link_to_repo with your repo's url. It can be found on your repository's home page under the green \"Code\" dropdown menu button.</p>"},{"location":"getting-started/connect_to_remote_repo/#push-local-files-to-remote","title":"Push local files to remote","text":"<p>Now that the remote repository is setup let's get all the code generated by the cookiecutter there.  </p> <p>First let's add all the project files to the local repository (remember we only initalized an empty repository):  </p> <p><code>$ git add .</code></p> <p>Next, commit those changes:  </p> <p><code>$ git commit -m \"Initialize repo\"</code></p> <p>Then, we name the current branch (with the files) to main:  </p> <p><code>$ git branch -M main</code></p> <p>Note if <code>main</code> is not used. You must change the branch reference in certain files within the '.github/workflows' directory for CI checks to work.</p> <p>Finally, lets push it to GitHub:  </p> <p><code>$ git push -u origin main</code></p> <p>That's it! Now you should see your GitHub repository with all the starter files. </p> <p>In addition, check out the \"Actions\" section of the repository to see the CI checks (docs deployment and code quality) being run. Once these are done, you'll see a <code>gh-pages</code> branch was created with odd files. Don't worry about that for now, it's the automatically generated documenation and we'll cover how to have that hosted on your own webpage in the next section.</p> <p>Continue on to see how to configure your GitHub repository to work optimally with the cookiecutter setup!</p>"},{"location":"getting-started/create_local_project/","title":"Getting started","text":""},{"location":"getting-started/create_local_project/#create-local-project","title":"Create local project","text":""},{"location":"getting-started/create_local_project/#setup-cookiecutter","title":"Setup cookiecutter","text":"<p>To start, install the latest Cookiecutter if you haven't installed it yet (this requires <code>Cookiecutter 1.4.0</code> or higher):  </p> <p><code>$ pip install -U cookiecutter&gt;=1.4.0</code></p>"},{"location":"getting-started/create_local_project/#create-local-project-via-cookiecutter","title":"Create local project via cookiecutter","text":"<p>Now you can use cookiecutter to generate your Python package project:</p> <p><code>$ cookiecutter https://github.com/mgancita/cookiecutter-pypackage.git</code></p> <p>If you will be publishing to PyPI, make sure the name of your project isn't already taken as you will be rejected from uploading to an already existing package.</p> <p>Now you should have a project directory for your code! Continue on to see how to get it onto GitHub.</p>"},{"location":"getting-started/publish_to_pypi/","title":"Publish to PyPI","text":""},{"location":"getting-started/publish_to_pypi/#differences-in-the-process","title":"Differences in the process","text":"<p>Now that we've published to test pypi. PyPI should be cake! Instead of re-writing the process with a few tweaks I'll mention the main differences here for getting to PyPI.</p> <ol> <li>Visit PyPI (not test pypi) to create an account.</li> <li>Go to the <code>API tokens</code> section with Account Settings.</li> <li>Generate a new API token and set it as <code>PYPI_TOKEN</code>.<ul> <li>Note that it should have a prefix of <code>pypi-</code> before a long token of characters.</li> </ul> </li> <li>For release: <ul> <li>Select <code>main branch</code>, </li> <li>Set tag version to <code>0.1.0</code>, </li> <li>Set release title to <code>v0.1.0</code>, </li> <li>Do NOT select \"This is pre-release\".</li> </ul> </li> </ol> <p>The <code>pip</code> command should be:  </p> <p><code>$ pip install your_package_name</code></p> <p>or</p> <p><code>$ pip install your_package_name==0.1.0</code></p> <p>if you wish to pin the version number.</p>"},{"location":"getting-started/publish_to_pypi/#use-your-code","title":"Use your code","text":"<p>Lastly, lets see how you would import your code. Lets say you have a package called test_project, with a module called test_file, and within that module a class called TestClass. After pip installing your code, in a Python file you could import the class like so,  </p> <p><code>from test_project.test_file import TestClass</code></p> <p>And that's it! Checkout the Advanced section if you'd like to learn more about the specific quality checks being used to test the code as well as why certain packages were used over others in this repository.</p>"},{"location":"getting-started/publish_to_test_pypi/","title":"Publish to test PyPI","text":""},{"location":"getting-started/publish_to_test_pypi/#what-is-pypi","title":"What is PyPI?","text":"<p>Great question! Python Package Index (PyPI) is where your computer goes (by default) when you <code>pip install</code> a package. By having your package on PyPI (don't worry it's 100% free), anyone can download your code with a single line command. I think that's pretty amazing!</p>"},{"location":"getting-started/publish_to_test_pypi/#cookiecutters-release-process","title":"Cookiecutter's release process","text":"<p>The cookiecutter creates a project which has a release action for release candidates and a seperate one for production releases. The logic for why is as follows, before merging into main (and releasing to production) the developer should develop the code on the <code>development</code> branch. With the <code>development</code> code thought to be ready for production, the developer would create a release candidate (otherwise known as pre-release) which ships the package to test pypi. This is done so the package can be downloaded and user-tested without messing up the release history of your pypi package. In addition, it's typically recommended to only have production-ready code on your main branch.</p> <p>With this being said, we'll have to create a pypi and test pypi account and configuration to have a robust packaging and testing process.</p> <p>Note the current release process uses username and password while token api key is recommended. I've been having issues getting tokens to work with poetry but it's a main priority to shift to a better system.</p>"},{"location":"getting-started/publish_to_test_pypi/#create-test-pypi-account","title":"Create test PyPI account","text":"<p>Before we're able to start publishing packages, we'll have to setup accounts. Visit test pypi and sign-up for an account.</p>"},{"location":"getting-started/publish_to_test_pypi/#setup-repository-secrets-for-test-pypi","title":"Setup repository secrets for test PyPI","text":"<p>Github Secrets is an amazing tools in which you can inject secret variables into your Github Actions without them being visible to the public, which is especially important for open-source projects. The cookiecutter's out-of-the-box continous deployment process to publish to test pypi looks for a few secret variables so we'll set those here.</p> <p>Navigate to the <code>API tokens</code> section of your Account Settings and generate a token. This token should start with <code>pypi-</code> and be followed by a long sequence of characters and numbers. Add that token as a secret called <code>TEST_PYPI_TOKEN</code> in your repositories secrets. If you use other variable names, you'll have to change the secret references in <code>.github/workflows/test_pypi_publish.yml</code>.</p>"},{"location":"getting-started/publish_to_test_pypi/#create-release-candidate","title":"Create release candidate","text":"<p>The time has come. These are the steps needed to publish to test pypi:</p> <ol> <li>Navigate to the <code>Releases</code> section of your repository.</li> <li>Click \"Create a new release\".</li> <li>Set <code>Tag version</code> to <code>0.1.0-rc0</code>.</li> <li>Select <code>development</code> branch.</li> <li>Set <code>Release title</code> to <code>Release Candidate: v0.1.0</code> (or a fun name).</li> <li>Select \"This is a pre-release\"</li> <li>Click \"Publish release\"</li> </ol> <p>Wait a few minutes (or watch the Github Action) for it to be published then visit your test pypi projects page to see the release.</p>"},{"location":"getting-started/publish_to_test_pypi/#install-package","title":"Install package","text":"<p>Now that you code is on test pypi it's as easy as <code>pip install</code> with one extra argument which is <code>--extra-index-url</code>. This allows pip to know to also check test pypi for your code. It should look like this:</p> <p><code>$ pip install your_package_name==0.1.0rc0 --extra-index-url=https://test.pypi.org/simple/</code></p> <p>As there is no release candidates (and therefore no <code>0.1.0rc0</code>) on pypi. This command would not be able to find the given release without the <code>extra-index-url</code>.</p> <p>And there it is! Your own package installable with a single command. Let's move on to see how to get it on PyPI!</p>"}]}